That's the most challenging, yet rewarding, phase! The goal of Phase 5 is to create bulletproof C++ firmware that maximizes reliability by separating slow tasks (Wi-Fi/File I/O) from critical tasks (Sensor Reading/Pumping) using the ESP32's FreeRTOS multitasking operating system.Create a file named PHASE5_FIRMWARE_FINALIZATION.md and paste the following comprehensive instructions for your Agent.‚öôÔ∏è PHASE 5: FIRMWARE FINALIZATION & SYSTEM INTEGRATIONObjective: Combine all logic (Sensors, Control, SD Card, Wi-Fi/API) into a robust, non-blocking C++ program using FreeRTOS tasks and a Mutex for file safety.Agent Persona: Embedded C++ Developer / FreeRTOS Specialist1. ‚öôÔ∏è FreeRTOS & Mutex SetupThe agent must define the structure to ensure concurrent tasks don't corrupt the SD card files.Action 1.1: Global ResourcesDeclare a global Mutex (SemaphoreHandle_t SD_MUTEX) to prevent simultaneous access to the SD card.Declare a Queue (QueueHandle_t Comm_Queue) to safely pass data packets (CSV strings) from the Sensor Task to the Communication Task.Action 1.2: Task InitializationIn the setup() function, initialize the Mutex and the Queue.Create the three main tasks using xTaskCreatePinnedToCore(), assigning them specific duties and cores:Task 1 (Sensor & Control): Core 1, High Priority (Fast, I/O-intensive).Task 2 (Communications & Sync): Core 0, Low Priority (Slow, Network-intensive).Task 3 (Watchdog): Core 0, Medium Priority (Monitors Wi-Fi health).2. üå≥ Task 1: Sensor Reading & Control Loop (Core 1)This task manages the physical hardware and ensures data collection is never blocked by network latency.Action 2.1: Calibration & ReadingWrite a function to perform an Analog Read (for moisture) and convert the raw $0-4095$ value into a calibrated $0-100 \text{ percent}$ value.Write a function to read the I2C sensors (Temp/Hum/Lux).Action 2.2: Control LogicImplement the core control logic: Check current moisture against the Target_Moisture from the database (or a local default). If too low, activate the physical pump relay for a set duration, then turn it off.Action 2.3: Data StagingAfter collection, the data is formatted into a CSV string. The task must then:ALWAYS Write to LIVE_LOG.csv: Use xSemaphoreTake(SD_MUTEX) before writing and xSemaphoreGive(SD_MUTEX) after to ensure exclusive file access.Queue for Cloud: Pass the CSV string to the Comm_Queue for immediate upload attempt by Task 2.3. üåê Task 2: Communications & Sync (Core 0)This task handles all networking and data integrity, running the "Write-Both" and "Sync Task" logic.Action 3.1: Primary Write-ThroughCheck the Comm_Queue. If a new data packet is present AND Wi-Fi is connected, build the JSON payload and perform the HTTP POST to the Phase 3 API endpoint.If the post fails (e.g., HTTP 500 error) or Wi-Fi is down: Write the data to SYNC_QUEUE.csv (using the Mutex).Action 3.2: Sync Task (The Core of Hybrid)Continuously check if SYNC_QUEUE.csv is not empty.If the queue exists, read the oldest line of CSV data.Attempt to POST this line to the API.CRITICAL: If the API returns HTTP 200/201 (Success), use the Mutex to DELETE the oldest line from the file. If it fails, stop syncing and retry on the next loop.4. üõ°Ô∏è Task 3: Watchdog & Error Handling (Core 0)This simple task ensures the system attempts recovery from basic failures.Action 4.1: Wi-Fi ReconnectPeriodically check the Wi-Fi status. If disconnected, attempt a non-blocking reconnect.Action 4.2: SD Card HealthAfter major file operations, check the status of the SD card. If a failure is detected, halt all further file I/O and display an error on the serial monitor.5. üìù Final Output RequirementOutput: The Agent must deliver the complete C++ pseudocode for the three FreeRTOS tasks and the main setup() function.